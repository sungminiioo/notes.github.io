# 📘 세션 기반 인증 vs 토큰 기반 인증

## 1. 세션 기반 인증

- **작동 방식**
    1. 사용자가 로그인 → 서버가 세션 ID 생성 후 DB/메모리 같은 저장소에 보관
    2. 세션 ID를 클라이언트의 **쿠키**에 저장
    3. 이후 요청마다 쿠키의 세션 ID를 확인하여 인증 여부 판단
- **특징**
    - 서버에 상태(세션 정보)를 저장해야 함 → 서버 메모리나 Redis 필요
    - 확장성(Scaling)이 떨어짐 → 여러 서버 사용 시 세션 동기화 필요
- **장점**
    - 구현이 단순하고 오래된 웹 시스템에 적합
    - 세션에 다양한 사용자 정보를 담을 수 있음
- **단점**
    - 서버 리소스 소모 (세션 저장 필요)
    - 분산 서버 환경에서 관리가 복잡

---

## 2. 토큰 기반 인증 (JWT, OAuth 등)

- **작동 방식**
    1. 사용자가 로그인 → 서버가 **토큰(JWT 등)** 발급
    2. 클라이언트는 토큰을 로컬 스토리지나 쿠키에 저장
    3. 요청 시 `Authorization` 헤더에 토큰을 포함해 전송
    4. 서버는 토큰만 검증하고 상태를 따로 저장하지 않음 (**Stateless**)
- **특징**
    - 서버는 토큰을 검증만 하면 되므로 **확장성 우수**
    - 모바일/웹/외부 API 같은 다양한 클라이언트 지원에 적합
- **장점**
    - 서버 상태 저장 불필요 → 마이크로서비스, 서버리스에 적합
    - 다양한 서비스 간 **Single Sign-On (SSO)** 구현 용이
- **단점**
    - 토큰 탈취 시 만료 전까지 무단 사용 가능
    - 토큰 크기가 세션 ID보다 커서 네트워크 비용 증가 가능

---

## 3. 사용하면 좋은 상황 예시

- **세션 기반 인증**
    - 단일 서버, 소규모 서비스 (예: 개인 블로그, 회사 내부 인트라넷)
    - 보안보다 구현 단순성이 중요한 경우
- **토큰 기반 인증**
    - 모바일 앱 + 웹 서비스 같이 멀티 플랫폼을 지원해야 하는 경우
    - 서버가 여러 대로 분산되어 있는 **대규모 서비스** (예: 전자상거래, 소셜 네트워크)
    - 외부 API 연동이 필요한 경우 (OAuth, OpenID Connect 등)

---

## ✅ 결론

- **세션 기반 인증**은 서버가 상태를 관리하기 때문에 소규모·단순한 서비스에서 적합
- **토큰 기반 인증**은 확장성과 다양한 클라이언트 지원에 강점이 있어 대규모·분산 환경에서 유리

# 모범 답안

# 📌 세션 기반 인증 vs 토큰 기반 인증

---

## 1️⃣ 세션 기반 인증

- **동작 원리**
    - 서버가 로그인 성공 시 **세션을 생성**하고, 세션 ID를 발급
    - 세션 ID는 **브라우저 쿠키에 저장**
    - 클라이언트 요청 시 쿠키를 통해 세션 ID를 서버로 전달 → 서버에서 사용자를 식별
- **장점**
    - 서버에서 사용자의 상태를 계속 추적 가능
    - **특정 세션 무효화 용이** → 해킹 대응 등 보안 강력
    - 사용자 상태 관리(장바구니, 로그인 유지 등)에 적합
- **단점**
    - 서버가 세션을 계속 관리해야 함 → **서버 자원 소모 큼**
    - 로그인 사용자가 많아지면 서버 확장성에 한계
    - RESTful API에 적합하지 않음 (stateful)
- **사용 예시**
    - 금융 서비스, 내부 관리 시스템
    - 높은 보안 + 세밀한 상태 관리 필요할 때

---

## 2️⃣ 토큰 기반 인증 (JWT)

- **동작 원리**
    - 서버가 인증 후 **JWT 토큰 발급**
    - 토큰 안에 사용자 정보(암호화된 claim) 포함
    - 클라이언트는 토큰을 저장하고, 이후 요청 시 **Authorization 헤더**에 실어 보냄
    - 서버는 토큰을 검증만 하면 됨 (상태 저장 X)
- **장점**
    - 서버에 사용자 상태 저장 불필요 → **확장성 높음**
    - RESTful API와 잘 어울림 (stateless)
    - 발급처와 검증처가 다를 수 있어 **유연한 서비스 통합** 가능
    - SPA, 모바일 앱 등 다양한 클라이언트에서 사용 가능
- **단점**
    - 특정 토큰을 강제로 무효화하기 어려움 → 로그아웃 처리 까다로움
    - 보안 민감 서비스에서는 위험할 수 있음 (추가 안전장치 필요)
- **사용 예시**
    - 대규모 서비스, 마이크로서비스 아키텍처
    - SNS, 모바일 앱, SPA 등

---

## 3️⃣ 비교

| 구분 | 세션 기반 인증 | 토큰 기반 인증 |
| --- | --- | --- |
| 저장 위치 | 서버(DB/메모리) | 클라이언트(쿠키/스토리지) |
| 확장성 | 낮음 (서버 부하 ↑) | 높음 (서버 stateless) |
| 보안 | 세션 무효화 쉬움 | 무효화 어려움 |
| RESTful | ❌ (stateful) | ✅ (stateless) |
| 효율성 | 서버에 상태 저장 → 부하 ↑ | 토큰 해석만 하면 됨 → 효율적 |
| 유연성 | 단일 서비스 환경 | 여러 서비스 간 통합 가능 |
| 적합 환경 | 금융, 내부 시스템 | 대규모/모바일 서비스 |

---

## 4️⃣ 핵심 정리

- **세션 기반 인증**
    - 서버가 상태를 기억하는 **stateful 방식**
    - 장점: 보안 & 세션 무효화 쉬움
    - 단점: 확장성 낮음
    - → 금융, 내부 시스템
- **토큰 기반 인증**
    - 서버가 상태를 기억하지 않는 **stateless 방식**
    - 장점: 확장성 & 유연성, RESTful에 적합
    - 단점: 토큰 무효화 어려움
    - → SPA, 모바일 앱, 대규모 서비스
