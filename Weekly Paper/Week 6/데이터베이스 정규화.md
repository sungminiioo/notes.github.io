# 📘 **데이터베이스 정규화란?**

> 중복을 제거하고, 데이터를 더 효율적으로 관리하기 위해 테이블을 구조화하는 과정
> 

---

## 🎯 **왜 정규화할까?**

- 데이터를 **일관성 있게 유지**하고
- **중복을 줄여서 저장 공간을 절약**하며
- 데이터 변경 시 **수정해야 할 부분을 최소화**하기 위해

---

## 🧩 **정규형의 단계별 요약**

| 정규형 | 조건 | 해결하는 문제 |
| --- | --- | --- |
| **1NF** (제1정규형) | 컬럼에 **반복되는 값 없이 원자값(단일 값)**만 저장 | 여러 값을 하나의 셀에 저장하는 문제 |
| **2NF** (제2정규형) | 1NF 만족 + **부분 함수 종속 제거** | 복합 키의 일부에만 의존하는 컬럼 제거 |
| **3NF** (제3정규형) | 2NF 만족 + **이행적 종속 제거** | 기본키 아닌 컬럼에 의존하는 다른 컬럼 제거 |
| **BCNF** (보이스-코드 정규형) | 3NF 만족 + 모든 결정자가 후보키 | 후보키가 아닌 컬럼이 결정자 역할할 때 해결 |

---

## 📝 **예시**

### ✅ 정규화 전 (중복 많음)

| 학생ID | 이름 | 과목 | 교수 |
| --- | --- | --- | --- |
| 1 | 철수 | 수학 | 김교수 |
| 1 | 철수 | 과학 | 이교수 |
- 철수라는 이름이 반복됨
- 교수 이름도 반복됨

### ✅ 정규화 후 (테이블 분리)

- **학생 테이블**: ID, 이름
- **과목 테이블**: 과목, 교수
- **수강 테이블**: 학생ID, 과목

➡️ 이렇게 하면 중복이 줄어들고, 나중에 교수나 과목이 바뀌어도 **한 군데만 수정**하면 됨!

---

## ✅ **핵심 정리**

- 정규화는 **데이터의 중복을 줄이고**, **무결성(정확성)**을 높이는 과정
- 정규형은 **단계별로 엄격해지며**, 실제로는 **3NF 정도까지만 적용**하는 경우가 많음

# 모범 답안

## 📌 React에서 배열 렌더링 시 `key`를 설정해야 하는 이유와 주의할 점

---

### 1️⃣ **왜 key가 필요한가?**

- `key`는 **React가 리스트 항목을 고유하게 식별**하는 기준입니다.
- 리스트 요소가 **추가/삭제/재정렬**될 때, 어떤 요소가 변경되었는지를 빠르게 파악하여 **필요한 부분만 갱신**할 수 있게 합니다.
- 이를 통해 **불필요한 DOM 재생성**을 방지하고 **렌더링 성능**을 최적화합니다.

**예시**

```jsx
const listItems = items.map(item =>
  <li key={item.id}>{item.name}</li>
);
```

---

### 2️⃣ **key가 없으면 생기는 문제**

- React는 각 요소의 변화를 구분할 수 없어, **모든 요소를 새로 렌더링**하게 됩니다.
- 이는 **성능 저하**와 **불필요한 DOM 조작**을 유발합니다.

---

### 3️⃣ **key 설정 시 주의할 점**

### ✅ 고유한 값 사용

- 동일한 리스트 내에서 `key`는 **중복되지 않아야 함**.
- **데이터베이스 ID**, **UUID** 등 **변하지 않는 값** 사용 권장.

```jsx
// 좋은 예시: 고유한 ID 사용
const listItems = items.map(item =>
  <li key={item.id}>{item.name}</li>
);
```

### ⚠️ 인덱스 사용 주의

- 배열 인덱스를 `key`로 쓰면, **요소 추가/삭제/정렬 시** 인덱스가 바뀌어 버그가 생길 수 있음.
- 특히 **동적인 리스트**에서는 피해야 함.

```jsx
// 나쁜 예시: 인덱스 사용
const listItems = items.map((item, index) =>
  <li key={index}>{item.name}</li>
);
```

---

### 4️⃣ **예외적으로 인덱스 사용 가능할 때**

- **정적인 리스트**이거나, 절대 변경/정렬되지 않는 경우
- 이 경우 인덱스 사용이 성능상 문제를 만들지 않음

```jsx
// 예외 상황: 변하지 않는 리스트
const staticItems = ['Item1', 'Item2', 'Item3'];
const listItems = staticItems.map((item, index) =>
  <li key={index}>{item}</li>
);
```

---

### 📌 **결론**

- **원칙**: 변하지 않는 **고유 식별자**를 `key`로 사용
- **지양**: 인덱스를 `key`로 사용 (동적 리스트에서 특히 위험)
- **효과**: DOM 변경 최소화 → 성능 최적화 & 예기치 않은 버그 방지
