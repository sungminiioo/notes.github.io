# useMemo & useCallback

### **useMemo**

- **값을 메모이제이션** → 비싼 계산을 매번 다시 하지 않도록 최적화

```jsx
const expensiveValue = useMemo(() => heavyCalculation(num), [num]);

```

### **useCallback**

- **함수를 메모이제이션** → 불필요한 함수 재생성과 자식 컴포넌트 리렌더링 방지

```jsx
const handleClick = useCallback(() => doSomething(), [dependency]);

```

### **언제 사용하면 좋은가?**

- **useMemo**: 계산 비용이 높은 값의 재계산 방지
- **useCallback**: 콜백 함수를 props로 넘길 때 참조 안정화 필요 시

### **남용 시 문제점**

- 메모이제이션도 비용이 듦 → 무분별한 사용 시 오히려 성능 저하
- 코드 복잡성 증가로 유지보수 어려움

**핵심 정리**

> useMemo와 useCallback은 성능 최적화 도구.
> 
> 
> **정말 필요한 경우에만** 사용하지 않으면 역효과 발생.
>

# 모범 답안

## useMemo와 useCallback

React의 **`useMemo`**와 **`useCallback`**은 성능 최적화를 위해 사용하는 **Hooks**입니다. 이 두 Hooks는 컴포넌트의 불필요한 재렌더링을 방지하여 성능을 향상시키는 데 도움을 줍니다.

---

### **useMemo의 기능과 차이점**

- *`useMemo`*는 **값의 메모이제이션**을 위해 사용됩니다.
- **목적**: 비용이 많이 드는 연산 결과를 메모리에 저장하여, 동일한 연산을 반복하지 않고 저장된 값을 재사용합니다.
- **효과**: 렌더링 성능을 최적화하는 데 유용합니다.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

```

위 예시에서 `computeExpensiveValue`는 `a`와 `b`가 변경되지 않는 한, 재계산되지 않고 이전의 계산된 값을 반환합니다.

---

### **useCallback의 기능과 차이점**

- *`useCallback`*은 **함수의 메모이제이션**을 위해 사용됩니다.
- **목적**: 전달된 함수를 다시 생성하지 않고 재사용할 수 있게 해줍니다.
- **효과**: 특히 하위 컴포넌트에 **props**로 함수를 전달할 때 불필요한 재렌더링을 방지하는 데 유용합니다.

```jsx
const memoizedCallback = useCallback(() => {
    doSomething(a, b);
}, [a, b]);

```

위 예시에서 `doSomething` 함수는 `a`와 `b`가 변경되지 않는 한, 재생성되지 않고 동일한 참조를 유지합니다.

---

### **useMemo와 useCallback의 사용 적절성**

### 1. **참조 동일성이 중요한 경우**

- 하위 컴포넌트에 **props**로 함수나 객체를 전달할 때, 해당 값들이 변경되지 않도록 유지해야 하는 경우 **`useCallback`** 또는 **`useMemo`*를 사용합니다.
- 이를 통해 하위 컴포넌트의 불필요한 재렌더링을 방지할 수 있습니다.

### 2. **비용이 많이 드는 연산**

- 복잡한 계산이 포함된 데이터를 렌더링할 때, 연산 결과를 메모이제이션하여 재사용함으로써 성능을 최적화할 수 있습니다.
- 예시:

```jsx
const filteredItems = useMemo(() => {
    return items.filter(item => item.active);
}, [items]);

```

### 3. **함수의 불필요한 재생성 방지**

- 자주 호출되는 함수나, 렌더링 시마다 새로 생성될 필요가 없는 함수를 메모이제이션하여 성능을 개선할 수 있습니다.
- 예시:

```jsx
const handleClick = useCallback(() => {
    console.log('Button clicked');
}, []);

```

---

### **useMemo와 useCallback의 남용 시 문제점**

### 1. **메모리 사용 비효율**

- 메모이제이션은 계산된 값을 메모리에 저장하므로, 불필요하게 많은 값을 저장하면 **애플리케이션의 메모리 사용량**이 증가할 수 있습니다.
- 메모리 사용량이 과도해지면 성능이 저하될 수 있습니다.

### 2. **동작 시간의 비효율**

- 메모이제이션을 통해 오히려 성능 저하가 일어날 수 있습니다.
- **메모이제이션의 오버헤드**로 인해, 실제로 최적화가 필요하지 않은 경우 **애플리케이션의 응답 시간이 느려질 수 있습니다.**

### 3. **관리 지점 증가**

- 의존성 배열을 제대로 관리하지 않으면 코드가 복잡해지고, **디버깅이 어려워질 수 있습니다**.
- 잘못된 의존성 배열 설정은 예기치 못한 버그를 초래할 수 있습니다.

---

### **결론**

`useMemo`와 `useCallback`은 React에서 성능 최적화를 위해 중요한 도구입니다. 값과 함수를 메모이제이션하여 불필요한 재렌더링을 방지하고, 성능을 향상시킬 수 있습니다. 하지만, 이 두 Hook을 남용하면 **메모리 사용 비효율**, **동작 시간의 비효율**, **관리 지점 증가** 등의 문제를 초래할 수 있으므로, **적절한 상황에서만 사용하는 것이 중요**합니다.
