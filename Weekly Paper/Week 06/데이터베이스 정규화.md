# 📘 **데이터베이스 정규화란?**

> 중복을 제거하고, 데이터를 더 효율적으로 관리하기 위해 테이블을 구조화하는 과정
> 

---

## 🎯 **왜 정규화할까?**

- 데이터를 **일관성 있게 유지**하고
- **중복을 줄여서 저장 공간을 절약**하며
- 데이터 변경 시 **수정해야 할 부분을 최소화**하기 위해

---

## 🧩 **정규형의 단계별 요약**

| 정규형 | 조건 | 해결하는 문제 |
| --- | --- | --- |
| **1NF** (제1정규형) | 컬럼에 **반복되는 값 없이 원자값(단일 값)**만 저장 | 여러 값을 하나의 셀에 저장하는 문제 |
| **2NF** (제2정규형) | 1NF 만족 + **부분 함수 종속 제거** | 복합 키의 일부에만 의존하는 컬럼 제거 |
| **3NF** (제3정규형) | 2NF 만족 + **이행적 종속 제거** | 기본키 아닌 컬럼에 의존하는 다른 컬럼 제거 |
| **BCNF** (보이스-코드 정규형) | 3NF 만족 + 모든 결정자가 후보키 | 후보키가 아닌 컬럼이 결정자 역할할 때 해결 |

---

## 📝 **예시**

### ✅ 정규화 전 (중복 많음)

| 학생ID | 이름 | 과목 | 교수 |
| --- | --- | --- | --- |
| 1 | 철수 | 수학 | 김교수 |
| 1 | 철수 | 과학 | 이교수 |
- 철수라는 이름이 반복됨
- 교수 이름도 반복됨

### ✅ 정규화 후 (테이블 분리)

- **학생 테이블**: ID, 이름
- **과목 테이블**: 과목, 교수
- **수강 테이블**: 학생ID, 과목

➡️ 이렇게 하면 중복이 줄어들고, 나중에 교수나 과목이 바뀌어도 **한 군데만 수정**하면 됨!

---

## ✅ **핵심 정리**

- 정규화는 **데이터의 중복을 줄이고**, **무결성(정확성)**을 높이는 과정
- 정규형은 **단계별로 엄격해지며**, 실제로는 **3NF 정도까지만 적용**하는 경우가 많음

# 모범 답안

## 📚 데이터베이스 정규화 (Normalization)

> 목적: 데이터 중복 최소화 & 무결성 유지
> 
> 
> **핵심 원칙**: 하나의 데이터는 한 번만 저장, 의미 있는 관계 유지
> 

---

### ✨ 정규화의 장점

- 🔄 **중복 최소화** → 데이터 일관성 유지
- 🛡 **무결성 강화** → 오류 가능성 감소
- ⚡ **검색·수정 효율 향상**

---

## 📌 정규화 단계별 설명 & 예시

---

### 1️⃣ 제1정규형 (1NF)

- 모든 컬럼은 **원자값**만 가져야 함 (하나의 칸에 여러 값 ❌)

**❌ 잘못된 예시**

```sql
CREATE TABLE Student (
    student_id INT PRIMARY KEY,
    name VARCHAR(50),
    hobbies VARCHAR(255) -- '독서, 음악, 영화'
);
```

**✅ 1NF 적용 예시**

```sql
CREATE TABLE Student (
    student_id INT,
    name VARCHAR(50),
    hobby VARCHAR(50),
    PRIMARY KEY (student_id, hobby)
);
```

| student_id | name | hobby |
| --- | --- | --- |
| 1 | 홍길동 | 독서 |
| 1 | 홍길동 | 음악 |

---

### 2️⃣ 제2정규형 (2NF)

- 1NF 만족 + **부분 함수 종속 제거**
- 복합키의 일부에만 종속된 컬럼을 분리

**❌ 잘못된 예시**

```sql
CREATE TABLE Enrollment (
    student_id INT,
    course_id INT,
    student_name VARCHAR(50), -- student_id에만 종속
    PRIMARY KEY (student_id, course_id)
);
```

**✅ 2NF 적용 예시**

```sql
CREATE TABLE Student (
    student_id INT PRIMARY KEY,
    student_name VARCHAR(50)
);

CREATE TABLE Enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES Student(student_id)
);
```

---

### 3️⃣ 제3정규형 (3NF)

- 2NF 만족 + **이행 함수 종속 제거**
- 기본 키가 아닌 컬럼이 다른 기본 키가 아닌 컬럼에 종속되면 분리

**❌ 잘못된 예시**

```sql
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    dept_name VARCHAR(50) -- dept_id에 종속
);
```

**✅ 3NF 적용 예시**

```sql
CREATE TABLE Department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);
```

---

### 4️⃣ 보이스-코드 정규형 (BCNF)

- 3NF 만족 + **모든 결정자가 후보 키**
- 후보 키가 아닌 속성이 결정자가 되지 않도록 설계

---

## ⚖️ 장단점

**장점**

- 데이터 중복 제거
- 무결성 유지
- 유지보수 용이

**단점**

- 테이블이 많아져 조인 연산 증가
- 성능 저하 가능성 → 일부 비정규화 고려 필요

---

💡 **결론**

정규화는 데이터 품질과 무결성을 높이는 필수 설계 과정이지만,

실제 서비스에서는 **성능 요구사항에 맞춰 적절한 단계까지만 적용**해야 함.
