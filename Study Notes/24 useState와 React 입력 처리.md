# useState와 React 입력 처리

### 📅 날짜:

> 2025.08.07 (목)
> 

### 📘 오늘 공부한 주제:

> React에서 입력 폼 다루기
> 

---

### 📝 핵심 개념 요약:

- `useState(initialState)`는 상태와 상태 변경 함수를 반환하며, `initialState`는 값 또는 콜백 함수로 전달 가능.
- 참조형 객체를 직접 수정하면 리렌더링이 발생하지 않으므로 반드시 새로운 객체를 만들어 전달해야 함.
- 상태 변경 시 이전 상태에 의존할 경우 `setState(prev => next)` 형태의 콜백 사용이 안정적.
- 네트워크 로딩/에러 처리는 사용자 경험을 개선하기 위해 반드시 고려해야 할 사항.
- React에서 입력 폼은 `useState`, `onChange`, `value`, `onSubmit` 조합으로 제어.

### 📌 핵심 요약 표

| 개념 | 설명 |
| --- | --- |
| 초기값 지정 | `useState(0)` 또는 `useState(() => 초기값 계산)` |
| 참조형 state 오류 | 직접 수정은 리렌더링 X (❌ `state.count++`) |
| 참조형 state 해결 | spread 문법으로 새로운 객체 생성 |
| 콜백으로 상태 변경 | `setState(prev => prev + 1)` |
| 로딩 처리 | 상태 관리 + UI 표시 (spinner 등) |
| 에러 처리 | 메시지 표시, 재시도, 대체 데이터 등 |
| 입력 폼 처리 | `value`, `onChange`, `onSubmit` 활용 |

### 💻 실습 내용 정리

- **초깃값 지정 실습**

`useState(0)`처럼 직접 값을 넣는 것과, `useState(() => 계산)`으로 콜백 함수로 초기값을 계산하는 방식 모두 실습함. 후자는 무거운 계산을 지연할 때 유리함.

- **setter 함수 실습**
    
    기본적인 `setState(state + 1)` 방식과, 이전 상태에 의존한 `setState(prev => prev + 1)` 형식을 각각 적용해봄.
    
- **참조형 state 오류 및 해결**
    
    `{ count: 0 }` 형태의 객체를 `useState`로 관리할 때 `state.count++` 방식은 리렌더링이 발생하지 않음을 실습으로 확인. 해결책으로 `setState({ ...state, count: state.count + 1 })` 형태로 spread 문법을 사용함.
    
- **비동기 상태 변경 실습**
    
    `await` 이후 상태 변경이 필요한 경우에는 `setState(prev => prev + 1)` 콜백 패턴이 정확함을 실습함. 예:
    
    ```jsx
    const handleAddClick = async () => {
      await addCount();
      setCount(prev => prev + 1);
    }
    ```
    
- **로딩 처리 기법 정리**
    - `isLoading` 상태를 통해 스피너 표시
    - `useEffect` 내에서 fetch 요청 처리
    - 백그라운드 로딩이나 lazy loading의 개념 정리
- **에러 처리 기법 정리**
    - 실패 시 사용자에게 메시지 표시
    - 자동 재시도 로직 구성 (간단히 retry count 예시 추가)
    - fallback 데이터 구성에 대한 개념 정리
- **입력 폼 상태 관리 실습**
    - `useState`로 입력값 상태 저장
    - `value={state}`로 상태 바인딩
    - `onChange={e => setState(e.target.value)}`
    - `onSubmit`으로 폼 전송 처리

### ❗ 헷갈렸던 점 / 문제 해결:

- 참조형 객체의 직접 수정은 상태가 변경되어도 리렌더링되지 않음 → 반드시 새로운 객체로 교체해야 함.
- `await` 이후 상태 변경이 예상대로 되지 않아 혼란스러웠지만, `prevState` 콜백을 쓰는 방식으로 해결.
- 입력값 상태가 바뀌지 않는 문제는 `value`와 `onChange` 바인딩 누락 때문이었음.

### 💡 느낀 점 / 배운 점:

- `useState`는 단순한 구조지만 참조형 상태나 비동기 업데이트에서는 사고를 명확히 해야 함.
- 네트워크 처리 시 로딩/에러에 대한 대응이 반드시 필요하며, UX 향상에 중요함.
- 입력 폼 제어 컴포넌트는 초기에 낯설지만, `value`와 `onChange` 패턴을 이해하면 구조가 명확해짐.

### 🏷️ 키워드 (태그):

`#React` `#useState` `#state 변경` `#콜백패턴` `#참조형 상태` `#로딩 처리` `#에러 처리` `#비동기 처리` 

| 날짜 | 주제 | 핵심 요약 | 실습 내용 | 문제 해결 / 느낀 점 | 키워드 태그 | 복습 필요 |
| --- | --- | --- | --- | --- | --- | --- |
| 2025-08-07 | useState와 입력 처리 | 상태 초깃값, 참조형 상태, 콜백 패턴, 로딩·에러 처리, 입력 폼 다루기 | 상태 초기화 방식, 참조형 오류 해결, 비동기 콜백 처리, 입력 폼 제어 실습 | 참조형 객체 직접 수정 시 렌더링 안 됨, 콜백 사용 시 해결 |  `#React` `#useState` `#참조형 상태` `#비동기 처리` `#입폼`   | ✅ |
