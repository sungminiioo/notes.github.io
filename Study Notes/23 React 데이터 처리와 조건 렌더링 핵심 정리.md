# React 데이터 처리와 조건 렌더링 핵심 정리

### 📅 날짜:

> 2025.08.05 (화)
> 

### 📘 오늘 공부한 주제:

> Rect에서 fetch와 useEffect 활용, 페이지네이션 방식, 조건부 렌더
> 

---

### 📝 핵심 개념 요약:

- `fetch` + `useEffect` → API 호출 및 데이터 관리
- 페이지네이션은 "데이터를 나누는 방식"
- 조건부 렌더링은 `&&`, `||`, 삼항 연산자 등으로 구현
- 상태(state)는 비동기적으로 변경되며, 이전 값을 기준으로 변경 시 콜백 사용 권장

### 📌 핵심 요약 표

| 개념 | 설명 |
| --- | --- |
| `fetchData()` | API 호출 후 `.then()`으로 데이터 처리 |
| `useEffect` | 컴포넌트 mount 시 데이터 불러오기 |
| 오프셋 페이지네이션 | `limit`, `offset` 기반, 간단하지만 중복 가능성 |
| 커서 페이지네이션 | ID 기반 요청, 성능 우수하나 복잡 |
| 조건부 렌더링 | `&&`, ` |
| 비동기 state 주의 | 즉시 반영 안됨 → `prevState` 기반 콜백 권장 |

### 💻 실습 내용 정리

- **API 요청 및 상태 저장**
    
    `fetch()`를 사용하여 데이터를 가져오는 `fetchData` 함수를 만들고, `useEffect`를 통해 컴포넌트가 마운트될 때 API를 호출했습니다. 데이터를 받아온 후 `useState`로 상태에 저장할 수 있도록 구성했습니다.
    
- **조건부 렌더링 구현**
    
    `show && <p>보인다</p>`처럼 `&&` 연산자를 이용해 true일 때만 요소가 렌더링되도록 하였고, `toggle ? <p>성공</p> : <p>실패</p>` 형태로 삼항 연산자도 활용해 다양한 조건부 UI를 테스트했습니다.
    
- **비동기 상태 업데이트 실습**
    
    `setCount(prev => prev + 1)` 형태로 이전 상태값을 기준으로 새로운 값을 설정하는 연습을 했습니다. `useEffect` 안에서 상태를 변경할 때 의존성 배열을 비워 컴포넌트 최초 렌더링에만 실행되도록 설정했습니다.
    
- **페이지네이션 원리 이해**
    
    오프셋 기반 페이지네이션은 `?limit=10&offset=0` 형식으로 데이터를 불러오는 방식이고, 커서 기반은 특정 ID를 기준으로 다음 데이터를 요청하는 방식이라는 점을 실습 예제 없이 개념적으로 학습했습니다.
    

### ❗ 헷갈렸던 점 / 문제 해결:

- `&&`, `||` 조건부 렌더링에서 숫자 `0`도 falsy 값이므로 주의가 필요함
- 비동기 상태 변경(setState)이 즉시 반영되지 않아 `prevState`를 사용해 해결

### 💡 느낀 점 / 배운 점:

- React는 렌더링에 강력하지만, 데이터 흐름과 비동기 처리를 이해해야 실무에서 안정적인 코드를 작성할 수 있다는 걸 느낌.
- 페이지네이션은 단순한 UI가 아니라, 성능과 사용자 경험에 중요한 요소임을 알게 됨.

### 🏷️ 키워드 (태그):

`#React` `#fetch` `#useEffect` `#페이지네이션` `#조건부 렌더링` `#비동기 상태` `#커서 기반` `#오프셋 기반` 

| 날짜 | 주제 | 핵심 요약 | 실습 내용 | 문제 해결 / 느낀 점 | 키워드 태그 | 복습 필요 |
| --- | --- | --- | --- | --- | --- | --- |
| 2025-08-05 | fetch & 조건부 렌더링 | API 호출, 페이지네이션, 조건부 렌더링, 비동기 state | `fetch`, `useEffect`, 조건부 렌더링, 상태 업데이트 | 0 렌더링 오류, 비동기 처리 이해 |  `#React` `#fetch` `#useEffect` `#페이지네이션` `#조건 렌더링`   | ✅ |
