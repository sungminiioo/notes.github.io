# 세션 기반 로그인 & 인가 구현

### 📅 날짜:

> 2025.10.31 (금)
> 

### 📘 오늘 공부한 주제:

> Express에서 세션 기반 로그인/인가 구현
> 

---

## 📝 핵심 개념 요약

- 세션(Session)은
**서버가 클라이언트 상태를 기억하기 위한 메커니즘**으로,
로그인 후 사용자 정보를 브라우저 쿠키에 저장된 세션 ID를 통해 식별한다.
- `express-session` 을 이용해 세션 생성 및 관리를 자동화하고, 로그인한 사용자를 인증·인가할 수 있다.

## 📊 핵심 요약 표

| 개념 | 설명 |
| --- | --- |
| **express-session** | 세션을 관리하는 핵심 미들웨어 |
| **secret** | 세션 암호화에 사용되는 키 |
| **resave** | 세션에 변경사항이 없을 때 다시 저장할지 여부 |
| **saveUninitialized** | 로그인 전 사용자도 세션을 생성할지 여부 |
| **req.session.userId** | 로그인한 사용자의 고유 식별자 저장 |
| **401 Unauthorized** | 인증되지 않은 요청 시 반환되는 HTTP 상태 코드 |
| **미들웨어 체이닝** | 여러 미들웨어를 순서대로 연결해 처리 흐름을 제어 |

### 💻 실습 내용 정리

### ✅ 1. 세션 기반 로그인 구현

```bash
npm i express-session
```

**src/app.js**

```jsx
import session from 'express-session';

app.use(
  session({
    secret: process.env.SESSION_SECRET, // ex) 'session_secret'
    resave: false,
    saveUninitialized: true,
  }),
);
```

**/session-login 엔드포인트**

```jsx
userController.post("/session-login", async (req, res, next) => {
  const { email, password } = req.body;
  try {
    if (!email || !password) {
      const error = new Error("email, password 가 모두 필요합니다.");
      error.code = 422;
      throw error;
    }
    const user = await userService.getUser(email, password);
    req.session.userId = user.id;
    res.json(user);
  } catch (error) {
    next(error);
  }
});
```

**테스트 (/session-login 성공 시 쿠키에 sid 발급)**

```bash
POST http://localhost:3000/session-login
Content-Type: application/json

{
  "email": "test1@test.com",
  "password": "test"
}
```

---

### ✅ 2. 세션 기반 인가 구현

**src/middlewares/auth.js**

```jsx
async function verifySessionLogin(req, res, next) {
  try {
    const { userId } = req.session;
    if (!userId) throwUnauthorizedError();

    const user = await userRepository.findById(userId);
    if (!user) throwUnauthorizedError();

    req.user = {
      id: user.id,
      email: user.email,
      name: user.name,
    };
    next();
  } catch (error) {
    next(error);
  }
}
```

**productController.js**

```jsx
productController.post(
  "/products",
  auth.verifySessionLogin, // 로그인 여부 확인
  async (req, res, next) => {
    // 로그인된 사용자만 접근 가능
  }
);
```

**결과**

- 로그인하지 않고 요청 시: `401 Unauthorized`
- 로그인 후 요청 시: `201 Created`

### ❗ 헷갈렸던 점 / 문제 해결:

- **헷갈렸던 점:**
    - `resave`, `saveUninitialized`의 차이와 의미가 불분명했음.
    - 로그인 안 한 사용자도 세션을 생성하는 이유가 궁금했음.
- **문제 해결:**
    - `resave: false` → 세션 내용이 바뀌지 않으면 재저장 X
    - `saveUninitialized: true` → 게스트도 세션ID 쿠키를 받을 수 있음 (방문자 추적 등 용도)
    - 로그인 서비스에서는 보통 `false`로 설정해 불필요한 세션 생성을 방지함.
    - `401 Unauthorized` 오류는 미들웨어 순서 누락이 원인 → controller 전에 auth 미들웨어 등록하여 해결.

### 💡 느낀 점 / 배운 점:

- Express의 세션 구조를 이해하니 **"로그인 상태를 서버에서 유지하는 원리"**가 명확해짐.
- `express-session`을 통해 **JWT 없이도 인증/인가를 단순하게 처리**할 수 있었음.
- 미들웨어 체이닝 순서가 프로그램 흐름을 결정한다는 점에서, 설계의 중요성을 느낌.
- 실제 로그인/인가의 “흐름”을 손으로 만들어보니 백엔드 구조 이해가 확실히 깊어졌음.

### 🏷️ 키워드 (태그):

`#express-session` `#세션` `#로그인` `#인증` `#인가` `#미들웨어` `#401Unauthorized` `#express`

| 날짜 | 주제 | 핵심 요약 | 실습 내용 | 문제 해결 / 느낀 점 | 키워드 태그 | 복습 필요 |
| --- | --- | --- | --- | --- | --- | --- |
| 2025-10-31 | 세션 기반 로그인 & 인가 구현 | express-session으로 세션을 설정하고, 로그인 상태를 세션에 저장하여 인증·인가 처리 | session 설정 → /session-login 구현 → auth 미들웨어 작성 → product 추가 요청 테스트 | 옵션(resave/saveUninitialized) 동작 이해, 인증 실패 시 401 해결, 세션 기반 구조 설계 감각 향상 | `#express-session` `#로그인` `#인가` `#미들웨어` | ✅ |
