# 더보기, 무한스크롤

### 📅 날짜:

> 2025.09.29 (월)
> 

### 📘 오늘 공부한 주제:

> useInfiniteQuery 기반 더보기 & 무한스크롤 데이터 로드
> 

---

## 📝 핵심 개념 요약

- 페이지네이션의 **현대적 대안**: 사용자의 인터랙션(버튼 클릭, 스크롤)에 따라 **추가 데이터 로드**
- `useInfiniteQuery` 사용 → **데이터 누적 관리**와 **다음 페이지 파악**이 용이
- 공통 특징
    1. 신규 데이터는 기존 데이터에 누적 (`pages`, `pageParams`)
    2. 다음 페이지 존재 여부(`hasNextPage`)에 따라 UI 제어
- 다음 페이지 판단 방식
    - `totalCount`를 아는 경우 → `nextPage <= totalPages ? nextPage : undefined`
    - 모르는 경우 → `lastPage.length === ITEMS_PER_PAGE ? nextPage : undefined`
- 무한스크롤 트리거 → **Intersection Observer API** (React에서는 `react-intersection-observer` 추천)

## 📊 핵심 요약 표

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| 데이터 구조 | `pages`, `pageParams` 로 누적 관리 | `pages: [page1, page2...]` |
| hasNextPage | 다음 페이지 존재 여부 | `undefined → false` |
| 더보기 버튼 | `hasNextPage`가 true일 때만 렌더링 | 클릭 → `fetchNextPage()` |
| 무한스크롤 | IO로 관찰 대상이 뷰포트에 들어오면 호출 | 마지막 아이템에 ref 설정 |
| nextPage 판별 | 총 개수 있음 → totalPages 기반 | 총 개수 없음 → 데이터 길이 기반 |

### 💻 실습 내용 정리

### 더보기 버튼

```jsx
{hasNextPage && (
  <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
    {isFetchingNextPage ? "로딩중..." : "더보기"}
  </button>
)}
```

### getNextPageParam (총 개수 아는 경우)

```jsx
getNextPageParam: (lastPage, allPages, lastPageParam) => {
  const nextPage = lastPageParam + 1;
  return nextPage <= lastPage.totalPages ? nextPage : undefined;
}
```

### getNextPageParam (총 개수 모르는 경우)

```jsx
getNextPageParam: (lastPage, allPages, lastPageParam) => {
  const nextPage = lastPageParam + 1;
  return lastPage.length === ITEMS_PER_PAGE ? nextPage : undefined;
}
```

### Intersection Observer (무한스크롤)

```jsx
const { ref } = useInView({
  threshold: 1,
  onChange: (inView) => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  },
});

<ul>
  {todos.map((todo, idx) => {
    const isLastItem = todos.length - 1 === idx;
    return (
      <TodoItem ref={isLastItem ? ref : null} key={todo.id} todo={todo} />
    );
  })}
</ul>
```

### ❗ 헷갈렸던 점 / 문제 해결:

- **총 데이터 개수를 알 수 없는 경우**, 마지막 페이지의 데이터 개수로만 판별해야 했음 → 요청이 한 번 더 불필요하게 발생할 수 있음.
- 무한스크롤 트리거 위치: **리스트 마지막 아이템에 ref 설정**하는 것이 정석.

### 💡 느낀 점 / 배운 점:

- 단순한 페이지네이션보다 **UX가 자연스럽고 현대적**임.
- `useInfiniteQuery`의 **정형화된 캐시 구조** 덕분에 구현이 간단해짐.
- 백엔드 응답 구조에 따라 **nextPage 판별 로직**을 잘 짜야 함.

### 🏷️ 키워드 (태그):

`#InfiniteScroll` `#LoadMore` `#React` `#useInfiniteQuery` `#IntersectionObserver` `#UX`

| 날짜 | 주제 | 핵심 요약 | 실습 내용 | 문제 해결 / 느낀 점 | 키워드 태그 | 복습 필요 |
| --- | --- | --- | --- | --- | --- | --- |
| 2025-09-29 | 더보기 / 무한스크롤 | useInfiniteQuery 기반 데이터 누적 관리, hasNextPage로 UI 제어, IO를 통한 자동 로드 | 더보기 버튼 구현, getNextPageParam 두 가지 방식, IntersectionObserver 활용 | 총 데이터 모르는 경우 판별 로직 주의, 무한스크롤 트리거 ref 위치 확실히 이해 | `#InfiniteScroll` `#React` `#TanStackQuery` | ✅ |
